//! DO NOT EDIT THIS MODULE BY HAND.
//! It is automatically generated by the sibling python script, `gen_text_matcher.py`.

use super::*;
pub fn do_match<IT>(
    last_end: usize,
    first_char: char,
    it: &mut Peekable<IT>,
) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    match first_char {
        '-' => match_dash_(last_end, it),
        'e' => match_e(last_end, it),
        'i' => match_i(last_end, it),
        'l' => match_l(last_end, it),
        's' => match_s(last_end, it),
        'u' => match_u(last_end, it),
        'v' => match_v(last_end, it),
        'd' => match_d(last_end, it),
        'a' => match_a(last_end, it),
        'b' => match_b(last_end, it),
        'c' => match_c(last_end, it),
        'f' => match_f(last_end, it),
        'j' => match_j(last_end, it),
        'n' => match_n(last_end, it),
        'o' => match_o(last_end, it),
        'p' => match_p(last_end, it),
        'r' => match_r(last_end, it),
        'w' => match_w(last_end, it),
        _ => (last_end, None),
    }
}

#[inline]
fn match_dash_<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('i') => {
                let (start, chr) = it.next().unwrap();
                match_dash_i(start + chr.len_utf8(), it)
            }
            Some('l') => {
                let (start, chr) = it.next().unwrap();
                match_dash_l(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_dash_i<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('n') => {
                let (start, chr) = it.next().unwrap();
                match_dash_in(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_dash_in<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('c') => {
                let (start, chr) = it.next().unwrap();
                match_dash_inc(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_dash_inc<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('l') => {
                let (start, chr) = it.next().unwrap();
                match_dash_incl(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_dash_incl<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('u') => {
                let (start, chr) = it.next().unwrap();
                match_dash_inclu(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_dash_inclu<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('d') => {
                let (start, chr) = it.next().unwrap();
                match_dash_includ(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_dash_includ<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('e') => {
                let (start, chr) = it.next().unwrap();
                match_dash_include(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_dash_include<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some(c) if !c.is_ascii_alphabetic() => (
                last_end,
                Some(TokenType::Directive(Directive::Include(IsSoft::Yes))),
            ),
            None => (
                last_end,
                Some(TokenType::Directive(Directive::Include(IsSoft::Yes))),
            ),

            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_dash_l<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('o') => {
                let (start, chr) = it.next().unwrap();
                match_dash_lo(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_dash_lo<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('a') => {
                let (start, chr) = it.next().unwrap();
                match_dash_loa(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_dash_loa<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('d') => {
                let (start, chr) = it.next().unwrap();
                match_dash_load(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_dash_load<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some(c) if !c.is_ascii_alphabetic() => (
                last_end,
                Some(TokenType::Directive(Directive::Load(IsSoft::Yes))),
            ),
            None => (
                last_end,
                Some(TokenType::Directive(Directive::Load(IsSoft::Yes))),
            ),

            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_e<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('x') => {
                let (start, chr) = it.next().unwrap();
                match_ex(start + chr.len_utf8(), it)
            }
            Some('l') => {
                let (start, chr) = it.next().unwrap();
                match_el(start + chr.len_utf8(), it)
            }
            Some('n') => {
                let (start, chr) = it.next().unwrap();
                match_en(start + chr.len_utf8(), it)
            }
            Some('r') => {
                let (start, chr) = it.next().unwrap();
                match_er(start + chr.len_utf8(), it)
            }
            Some('v') => {
                let (start, chr) = it.next().unwrap();
                match_ev(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_ex<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('p') => {
                let (start, chr) = it.next().unwrap();
                match_exp(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_exp<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('o') => {
                let (start, chr) = it.next().unwrap();
                match_expo(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_expo<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('r') => {
                let (start, chr) = it.next().unwrap();
                match_expor(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_expor<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('t') => {
                let (start, chr) = it.next().unwrap();
                match_export(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_export<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some(c) if !c.is_ascii_alphabetic() => {
                (last_end, Some(TokenType::Directive(Directive::Export)))
            }
            None => (last_end, Some(TokenType::Directive(Directive::Export))),

            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_el<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('s') => {
                let (start, chr) = it.next().unwrap();
                match_els(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_els<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('e') => {
                let (start, chr) = it.next().unwrap();
                match_else(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_else<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some(c) if !c.is_ascii_alphabetic() => {
                (last_end, Some(TokenType::Directive(Directive::Else)))
            }
            None => (last_end, Some(TokenType::Directive(Directive::Else))),

            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_en<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('d') => {
                let (start, chr) = it.next().unwrap();
                match_end(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_end<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('i') => {
                let (start, chr) = it.next().unwrap();
                match_endi(start + chr.len_utf8(), it)
            }
            Some('d') => {
                let (start, chr) = it.next().unwrap();
                match_endd(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_endi<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('f') => {
                let (start, chr) = it.next().unwrap();
                match_endif(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_endif<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some(c) if !c.is_ascii_alphabetic() => {
                (last_end, Some(TokenType::Directive(Directive::EndIf)))
            }
            None => (last_end, Some(TokenType::Directive(Directive::EndIf))),

            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_endd<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('e') => {
                let (start, chr) = it.next().unwrap();
                match_endde(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_endde<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('f') => {
                let (start, chr) = it.next().unwrap();
                match_enddef(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_enddef<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some(c) if !c.is_ascii_alphabetic() => {
                (last_end, Some(TokenType::Directive(Directive::Enddef)))
            }
            None => (last_end, Some(TokenType::Directive(Directive::Enddef))),

            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_er<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('r') => {
                let (start, chr) = it.next().unwrap();
                match_err(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_err<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('o') => {
                let (start, chr) = it.next().unwrap();
                match_erro(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_erro<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('r') => {
                let (start, chr) = it.next().unwrap();
                match_error(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_error<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some(c) if !c.is_ascii_alphabetic() => (
                last_end,
                Some(TokenType::BuiltinFunction(BuiltinFunction::Error)),
            ),
            None => (
                last_end,
                Some(TokenType::BuiltinFunction(BuiltinFunction::Error)),
            ),

            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_ev<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('a') => {
                let (start, chr) = it.next().unwrap();
                match_eva(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_eva<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('l') => {
                let (start, chr) = it.next().unwrap();
                match_eval(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_eval<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some(c) if !c.is_ascii_alphabetic() => (
                last_end,
                Some(TokenType::BuiltinFunction(BuiltinFunction::Eval)),
            ),
            None => (
                last_end,
                Some(TokenType::BuiltinFunction(BuiltinFunction::Eval)),
            ),

            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_i<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('n') => {
                let (start, chr) = it.next().unwrap();
                match_in(start + chr.len_utf8(), it)
            }
            Some('f') => {
                let (start, chr) = it.next().unwrap();
                match_if(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_in<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('c') => {
                let (start, chr) = it.next().unwrap();
                match_inc(start + chr.len_utf8(), it)
            }
            Some('f') => {
                let (start, chr) = it.next().unwrap();
                match_inf(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_inc<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('l') => {
                let (start, chr) = it.next().unwrap();
                match_incl(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_incl<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('u') => {
                let (start, chr) = it.next().unwrap();
                match_inclu(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_inclu<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('d') => {
                let (start, chr) = it.next().unwrap();
                match_includ(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_includ<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('e') => {
                let (start, chr) = it.next().unwrap();
                match_include(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_include<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some(c) if !c.is_ascii_alphabetic() => (
                last_end,
                Some(TokenType::Directive(Directive::Include(IsSoft::No))),
            ),
            None => (
                last_end,
                Some(TokenType::Directive(Directive::Include(IsSoft::No))),
            ),

            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_inf<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('o') => {
                let (start, chr) = it.next().unwrap();
                match_info(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_info<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some(c) if !c.is_ascii_alphabetic() => (
                last_end,
                Some(TokenType::BuiltinFunction(BuiltinFunction::Info)),
            ),
            None => (
                last_end,
                Some(TokenType::BuiltinFunction(BuiltinFunction::Info)),
            ),

            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_if<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('d') => {
                let (start, chr) = it.next().unwrap();
                match_ifd(start + chr.len_utf8(), it)
            }
            Some('e') => {
                let (start, chr) = it.next().unwrap();
                match_ife(start + chr.len_utf8(), it)
            }
            Some('n') => {
                let (start, chr) = it.next().unwrap();
                match_ifn(start + chr.len_utf8(), it)
            }
            Some(c) if !c.is_ascii_alphabetic() => (
                last_end,
                Some(TokenType::BuiltinFunction(BuiltinFunction::If)),
            ),
            None => (
                last_end,
                Some(TokenType::BuiltinFunction(BuiltinFunction::If)),
            ),

            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_ifd<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('e') => {
                let (start, chr) = it.next().unwrap();
                match_ifde(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_ifde<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('f') => {
                let (start, chr) = it.next().unwrap();
                match_ifdef(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_ifdef<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some(c) if !c.is_ascii_alphabetic() => {
                (last_end, Some(TokenType::Directive(Directive::IfDef)))
            }
            None => (last_end, Some(TokenType::Directive(Directive::IfDef))),

            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_ife<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('q') => {
                let (start, chr) = it.next().unwrap();
                match_ifeq(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_ifeq<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some(c) if !c.is_ascii_alphabetic() => {
                (last_end, Some(TokenType::Directive(Directive::IfEq)))
            }
            None => (last_end, Some(TokenType::Directive(Directive::IfEq))),

            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_ifn<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('d') => {
                let (start, chr) = it.next().unwrap();
                match_ifnd(start + chr.len_utf8(), it)
            }
            Some('e') => {
                let (start, chr) = it.next().unwrap();
                match_ifne(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_ifnd<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('e') => {
                let (start, chr) = it.next().unwrap();
                match_ifnde(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_ifnde<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('f') => {
                let (start, chr) = it.next().unwrap();
                match_ifndef(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_ifndef<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some(c) if !c.is_ascii_alphabetic() => {
                (last_end, Some(TokenType::Directive(Directive::IfNDef)))
            }
            None => (last_end, Some(TokenType::Directive(Directive::IfNDef))),

            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_ifne<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('q') => {
                let (start, chr) = it.next().unwrap();
                match_ifneq(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_ifneq<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some(c) if !c.is_ascii_alphabetic() => {
                (last_end, Some(TokenType::Directive(Directive::IfNEq)))
            }
            None => (last_end, Some(TokenType::Directive(Directive::IfNEq))),

            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_l<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('o') => {
                let (start, chr) = it.next().unwrap();
                match_lo(start + chr.len_utf8(), it)
            }
            Some('a') => {
                let (start, chr) = it.next().unwrap();
                match_la(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_lo<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('a') => {
                let (start, chr) = it.next().unwrap();
                match_loa(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_loa<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('d') => {
                let (start, chr) = it.next().unwrap();
                match_load(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_load<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some(c) if !c.is_ascii_alphabetic() => (
                last_end,
                Some(TokenType::Directive(Directive::Load(IsSoft::No))),
            ),
            None => (
                last_end,
                Some(TokenType::Directive(Directive::Load(IsSoft::No))),
            ),

            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_la<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('s') => {
                let (start, chr) = it.next().unwrap();
                match_las(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_las<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('t') => {
                let (start, chr) = it.next().unwrap();
                match_last(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_last<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('w') => {
                let (start, chr) = it.next().unwrap();
                match_lastw(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_lastw<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('o') => {
                let (start, chr) = it.next().unwrap();
                match_lastwo(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_lastwo<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('r') => {
                let (start, chr) = it.next().unwrap();
                match_lastwor(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_lastwor<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('d') => {
                let (start, chr) = it.next().unwrap();
                match_lastword(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_lastword<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some(c) if !c.is_ascii_alphabetic() => (
                last_end,
                Some(TokenType::BuiltinFunction(BuiltinFunction::LastWord)),
            ),
            None => (
                last_end,
                Some(TokenType::BuiltinFunction(BuiltinFunction::LastWord)),
            ),

            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_s<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('i') => {
                let (start, chr) = it.next().unwrap();
                match_si(start + chr.len_utf8(), it)
            }
            Some('o') => {
                let (start, chr) = it.next().unwrap();
                match_so(start + chr.len_utf8(), it)
            }
            Some('t') => {
                let (start, chr) = it.next().unwrap();
                match_st(start + chr.len_utf8(), it)
            }
            Some('u') => {
                let (start, chr) = it.next().unwrap();
                match_su(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_si<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('n') => {
                let (start, chr) = it.next().unwrap();
                match_sin(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_sin<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('c') => {
                let (start, chr) = it.next().unwrap();
                match_sinc(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_sinc<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('l') => {
                let (start, chr) = it.next().unwrap();
                match_sincl(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_sincl<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('u') => {
                let (start, chr) = it.next().unwrap();
                match_sinclu(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_sinclu<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('d') => {
                let (start, chr) = it.next().unwrap();
                match_sinclud(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_sinclud<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('e') => {
                let (start, chr) = it.next().unwrap();
                match_sinclude(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_sinclude<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some(c) if !c.is_ascii_alphabetic() => (
                last_end,
                Some(TokenType::Directive(Directive::Include(IsSoft::Yes))),
            ),
            None => (
                last_end,
                Some(TokenType::Directive(Directive::Include(IsSoft::Yes))),
            ),

            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_so<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('r') => {
                let (start, chr) = it.next().unwrap();
                match_sor(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_sor<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('t') => {
                let (start, chr) = it.next().unwrap();
                match_sort(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_sort<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some(c) if !c.is_ascii_alphabetic() => (
                last_end,
                Some(TokenType::BuiltinFunction(BuiltinFunction::Sort)),
            ),
            None => (
                last_end,
                Some(TokenType::BuiltinFunction(BuiltinFunction::Sort)),
            ),

            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_st<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('r') => {
                let (start, chr) = it.next().unwrap();
                match_str(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_str<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('i') => {
                let (start, chr) = it.next().unwrap();
                match_stri(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_stri<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('p') => {
                let (start, chr) = it.next().unwrap();
                match_strip(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_strip<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some(c) if !c.is_ascii_alphabetic() => (
                last_end,
                Some(TokenType::BuiltinFunction(BuiltinFunction::Strip)),
            ),
            None => (
                last_end,
                Some(TokenType::BuiltinFunction(BuiltinFunction::Strip)),
            ),

            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_su<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('b') => {
                let (start, chr) = it.next().unwrap();
                match_sub(start + chr.len_utf8(), it)
            }
            Some('f') => {
                let (start, chr) = it.next().unwrap();
                match_suf(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_sub<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('s') => {
                let (start, chr) = it.next().unwrap();
                match_subs(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_subs<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('t') => {
                let (start, chr) = it.next().unwrap();
                match_subst(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_subst<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some(c) if !c.is_ascii_alphabetic() => (
                last_end,
                Some(TokenType::BuiltinFunction(BuiltinFunction::Subst)),
            ),
            None => (
                last_end,
                Some(TokenType::BuiltinFunction(BuiltinFunction::Subst)),
            ),

            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_suf<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('f') => {
                let (start, chr) = it.next().unwrap();
                match_suff(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_suff<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('i') => {
                let (start, chr) = it.next().unwrap();
                match_suffi(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_suffi<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('x') => {
                let (start, chr) = it.next().unwrap();
                match_suffix(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_suffix<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some(c) if !c.is_ascii_alphabetic() => (
                last_end,
                Some(TokenType::BuiltinFunction(BuiltinFunction::Suffix)),
            ),
            None => (
                last_end,
                Some(TokenType::BuiltinFunction(BuiltinFunction::Suffix)),
            ),

            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_u<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('n') => {
                let (start, chr) = it.next().unwrap();
                match_un(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_un<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('e') => {
                let (start, chr) = it.next().unwrap();
                match_une(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_une<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('x') => {
                let (start, chr) = it.next().unwrap();
                match_unex(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_unex<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('p') => {
                let (start, chr) = it.next().unwrap();
                match_unexp(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_unexp<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('o') => {
                let (start, chr) = it.next().unwrap();
                match_unexpo(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_unexpo<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('r') => {
                let (start, chr) = it.next().unwrap();
                match_unexpor(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_unexpor<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('t') => {
                let (start, chr) = it.next().unwrap();
                match_unexport(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_unexport<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some(c) if !c.is_ascii_alphabetic() => {
                (last_end, Some(TokenType::Directive(Directive::UnExport)))
            }
            None => (last_end, Some(TokenType::Directive(Directive::UnExport))),

            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_v<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('p') => {
                let (start, chr) = it.next().unwrap();
                match_vp(start + chr.len_utf8(), it)
            }
            Some('a') => {
                let (start, chr) = it.next().unwrap();
                match_va(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_vp<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('a') => {
                let (start, chr) = it.next().unwrap();
                match_vpa(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_vpa<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('t') => {
                let (start, chr) = it.next().unwrap();
                match_vpat(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_vpat<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('h') => {
                let (start, chr) = it.next().unwrap();
                match_vpath(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_vpath<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some(c) if !c.is_ascii_alphabetic() => {
                (last_end, Some(TokenType::Directive(Directive::VPath)))
            }
            None => (last_end, Some(TokenType::Directive(Directive::VPath))),

            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_va<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('l') => {
                let (start, chr) = it.next().unwrap();
                match_val(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_val<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('u') => {
                let (start, chr) = it.next().unwrap();
                match_valu(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_valu<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('e') => {
                let (start, chr) = it.next().unwrap();
                match_value(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_value<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some(c) if !c.is_ascii_alphabetic() => (
                last_end,
                Some(TokenType::BuiltinFunction(BuiltinFunction::Value)),
            ),
            None => (
                last_end,
                Some(TokenType::BuiltinFunction(BuiltinFunction::Value)),
            ),

            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_d<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('e') => {
                let (start, chr) = it.next().unwrap();
                match_de(start + chr.len_utf8(), it)
            }
            Some('i') => {
                let (start, chr) = it.next().unwrap();
                match_di(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_de<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('f') => {
                let (start, chr) = it.next().unwrap();
                match_def(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_def<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('i') => {
                let (start, chr) = it.next().unwrap();
                match_defi(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_defi<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('n') => {
                let (start, chr) = it.next().unwrap();
                match_defin(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_defin<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('e') => {
                let (start, chr) = it.next().unwrap();
                match_define(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_define<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some(c) if !c.is_ascii_alphabetic() => {
                (last_end, Some(TokenType::Directive(Directive::Define)))
            }
            None => (last_end, Some(TokenType::Directive(Directive::Define))),

            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_di<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('r') => {
                let (start, chr) = it.next().unwrap();
                match_dir(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_dir<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some(c) if !c.is_ascii_alphabetic() => (
                last_end,
                Some(TokenType::BuiltinFunction(BuiltinFunction::Dir)),
            ),
            None => (
                last_end,
                Some(TokenType::BuiltinFunction(BuiltinFunction::Dir)),
            ),

            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_a<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('b') => {
                let (start, chr) = it.next().unwrap();
                match_ab(start + chr.len_utf8(), it)
            }
            Some('d') => {
                let (start, chr) = it.next().unwrap();
                match_ad(start + chr.len_utf8(), it)
            }
            Some('n') => {
                let (start, chr) = it.next().unwrap();
                match_an(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_ab<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('s') => {
                let (start, chr) = it.next().unwrap();
                match_abs(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_abs<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('p') => {
                let (start, chr) = it.next().unwrap();
                match_absp(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_absp<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('a') => {
                let (start, chr) = it.next().unwrap();
                match_abspa(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_abspa<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('t') => {
                let (start, chr) = it.next().unwrap();
                match_abspat(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_abspat<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('h') => {
                let (start, chr) = it.next().unwrap();
                match_abspath(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_abspath<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some(c) if !c.is_ascii_alphabetic() => (
                last_end,
                Some(TokenType::BuiltinFunction(BuiltinFunction::Abspath)),
            ),
            None => (
                last_end,
                Some(TokenType::BuiltinFunction(BuiltinFunction::Abspath)),
            ),

            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_ad<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('d') => {
                let (start, chr) = it.next().unwrap();
                match_add(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_add<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('p') => {
                let (start, chr) = it.next().unwrap();
                match_addp(start + chr.len_utf8(), it)
            }
            Some('s') => {
                let (start, chr) = it.next().unwrap();
                match_adds(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_addp<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('r') => {
                let (start, chr) = it.next().unwrap();
                match_addpr(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_addpr<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('e') => {
                let (start, chr) = it.next().unwrap();
                match_addpre(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_addpre<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('f') => {
                let (start, chr) = it.next().unwrap();
                match_addpref(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_addpref<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('i') => {
                let (start, chr) = it.next().unwrap();
                match_addprefi(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_addprefi<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('x') => {
                let (start, chr) = it.next().unwrap();
                match_addprefix(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_addprefix<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some(c) if !c.is_ascii_alphabetic() => (
                last_end,
                Some(TokenType::BuiltinFunction(BuiltinFunction::AddPrefix)),
            ),
            None => (
                last_end,
                Some(TokenType::BuiltinFunction(BuiltinFunction::AddPrefix)),
            ),

            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_adds<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('u') => {
                let (start, chr) = it.next().unwrap();
                match_addsu(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_addsu<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('f') => {
                let (start, chr) = it.next().unwrap();
                match_addsuf(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_addsuf<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('f') => {
                let (start, chr) = it.next().unwrap();
                match_addsuff(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_addsuff<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('i') => {
                let (start, chr) = it.next().unwrap();
                match_addsuffi(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_addsuffi<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('x') => {
                let (start, chr) = it.next().unwrap();
                match_addsuffix(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_addsuffix<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some(c) if !c.is_ascii_alphabetic() => (
                last_end,
                Some(TokenType::BuiltinFunction(BuiltinFunction::AddSuffix)),
            ),
            None => (
                last_end,
                Some(TokenType::BuiltinFunction(BuiltinFunction::AddSuffix)),
            ),

            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_an<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('d') => {
                let (start, chr) = it.next().unwrap();
                match_and(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_and<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some(c) if !c.is_ascii_alphabetic() => (
                last_end,
                Some(TokenType::BuiltinFunction(BuiltinFunction::And)),
            ),
            None => (
                last_end,
                Some(TokenType::BuiltinFunction(BuiltinFunction::And)),
            ),

            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_b<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('a') => {
                let (start, chr) = it.next().unwrap();
                match_ba(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_ba<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('s') => {
                let (start, chr) = it.next().unwrap();
                match_bas(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_bas<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('e') => {
                let (start, chr) = it.next().unwrap();
                match_base(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_base<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('n') => {
                let (start, chr) = it.next().unwrap();
                match_basen(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_basen<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('a') => {
                let (start, chr) = it.next().unwrap();
                match_basena(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_basena<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('m') => {
                let (start, chr) = it.next().unwrap();
                match_basenam(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_basenam<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('e') => {
                let (start, chr) = it.next().unwrap();
                match_basename(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_basename<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some(c) if !c.is_ascii_alphabetic() => (
                last_end,
                Some(TokenType::BuiltinFunction(BuiltinFunction::BaseName)),
            ),
            None => (
                last_end,
                Some(TokenType::BuiltinFunction(BuiltinFunction::BaseName)),
            ),

            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_c<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('a') => {
                let (start, chr) = it.next().unwrap();
                match_ca(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_ca<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('l') => {
                let (start, chr) = it.next().unwrap();
                match_cal(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_cal<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('l') => {
                let (start, chr) = it.next().unwrap();
                match_call(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_call<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some(c) if !c.is_ascii_alphabetic() => (
                last_end,
                Some(TokenType::BuiltinFunction(BuiltinFunction::Call)),
            ),
            None => (
                last_end,
                Some(TokenType::BuiltinFunction(BuiltinFunction::Call)),
            ),

            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_f<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('i') => {
                let (start, chr) = it.next().unwrap();
                match_fi(start + chr.len_utf8(), it)
            }
            Some('l') => {
                let (start, chr) = it.next().unwrap();
                match_fl(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_fi<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('l') => {
                let (start, chr) = it.next().unwrap();
                match_fil(start + chr.len_utf8(), it)
            }
            Some('n') => {
                let (start, chr) = it.next().unwrap();
                match_fin(start + chr.len_utf8(), it)
            }
            Some('r') => {
                let (start, chr) = it.next().unwrap();
                match_fir(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_fil<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('e') => {
                let (start, chr) = it.next().unwrap();
                match_file(start + chr.len_utf8(), it)
            }
            Some('t') => {
                let (start, chr) = it.next().unwrap();
                match_filt(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_file<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some(c) if !c.is_ascii_alphabetic() => (
                last_end,
                Some(TokenType::BuiltinFunction(BuiltinFunction::File)),
            ),
            None => (
                last_end,
                Some(TokenType::BuiltinFunction(BuiltinFunction::File)),
            ),

            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_filt<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('e') => {
                let (start, chr) = it.next().unwrap();
                match_filte(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_filte<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('r') => {
                let (start, chr) = it.next().unwrap();
                match_filter(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_filter<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('o') => {
                let (start, chr) = it.next().unwrap();
                match_filtero(start + chr.len_utf8(), it)
            }
            Some(c) if !c.is_ascii_alphabetic() => (
                last_end,
                Some(TokenType::BuiltinFunction(BuiltinFunction::Filter)),
            ),
            None => (
                last_end,
                Some(TokenType::BuiltinFunction(BuiltinFunction::Filter)),
            ),

            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_filtero<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('u') => {
                let (start, chr) = it.next().unwrap();
                match_filterou(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_filterou<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('t') => {
                let (start, chr) = it.next().unwrap();
                match_filterout(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_filterout<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some(c) if !c.is_ascii_alphabetic() => (
                last_end,
                Some(TokenType::BuiltinFunction(BuiltinFunction::FilterOut)),
            ),
            None => (
                last_end,
                Some(TokenType::BuiltinFunction(BuiltinFunction::FilterOut)),
            ),

            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_fin<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('d') => {
                let (start, chr) = it.next().unwrap();
                match_find(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_find<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('s') => {
                let (start, chr) = it.next().unwrap();
                match_finds(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_finds<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('t') => {
                let (start, chr) = it.next().unwrap();
                match_findst(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_findst<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('r') => {
                let (start, chr) = it.next().unwrap();
                match_findstr(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_findstr<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('i') => {
                let (start, chr) = it.next().unwrap();
                match_findstri(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_findstri<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('n') => {
                let (start, chr) = it.next().unwrap();
                match_findstrin(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_findstrin<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('g') => {
                let (start, chr) = it.next().unwrap();
                match_findstring(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_findstring<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some(c) if !c.is_ascii_alphabetic() => (
                last_end,
                Some(TokenType::BuiltinFunction(BuiltinFunction::FindString)),
            ),
            None => (
                last_end,
                Some(TokenType::BuiltinFunction(BuiltinFunction::FindString)),
            ),

            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_fir<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('s') => {
                let (start, chr) = it.next().unwrap();
                match_firs(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_firs<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('t') => {
                let (start, chr) = it.next().unwrap();
                match_first(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_first<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('w') => {
                let (start, chr) = it.next().unwrap();
                match_firstw(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_firstw<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('o') => {
                let (start, chr) = it.next().unwrap();
                match_firstwo(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_firstwo<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('r') => {
                let (start, chr) = it.next().unwrap();
                match_firstwor(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_firstwor<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('d') => {
                let (start, chr) = it.next().unwrap();
                match_firstword(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_firstword<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some(c) if !c.is_ascii_alphabetic() => (
                last_end,
                Some(TokenType::BuiltinFunction(BuiltinFunction::FirstWord)),
            ),
            None => (
                last_end,
                Some(TokenType::BuiltinFunction(BuiltinFunction::FirstWord)),
            ),

            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_fl<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('a') => {
                let (start, chr) = it.next().unwrap();
                match_fla(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_fla<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('v') => {
                let (start, chr) = it.next().unwrap();
                match_flav(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_flav<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('o') => {
                let (start, chr) = it.next().unwrap();
                match_flavo(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_flavo<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('r') => {
                let (start, chr) = it.next().unwrap();
                match_flavor(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_flavor<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some(c) if !c.is_ascii_alphabetic() => (
                last_end,
                Some(TokenType::BuiltinFunction(BuiltinFunction::Flavor)),
            ),
            None => (
                last_end,
                Some(TokenType::BuiltinFunction(BuiltinFunction::Flavor)),
            ),

            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_j<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('o') => {
                let (start, chr) = it.next().unwrap();
                match_jo(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_jo<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('i') => {
                let (start, chr) = it.next().unwrap();
                match_joi(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_joi<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('n') => {
                let (start, chr) = it.next().unwrap();
                match_join(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_join<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some(c) if !c.is_ascii_alphabetic() => (
                last_end,
                Some(TokenType::BuiltinFunction(BuiltinFunction::Join)),
            ),
            None => (
                last_end,
                Some(TokenType::BuiltinFunction(BuiltinFunction::Join)),
            ),

            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_n<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('o') => {
                let (start, chr) = it.next().unwrap();
                match_no(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_no<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('t') => {
                let (start, chr) = it.next().unwrap();
                match_not(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_not<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('d') => {
                let (start, chr) = it.next().unwrap();
                match_notd(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_notd<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('i') => {
                let (start, chr) = it.next().unwrap();
                match_notdi(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_notdi<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('r') => {
                let (start, chr) = it.next().unwrap();
                match_notdir(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_notdir<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some(c) if !c.is_ascii_alphabetic() => (
                last_end,
                Some(TokenType::BuiltinFunction(BuiltinFunction::NotDir)),
            ),
            None => (
                last_end,
                Some(TokenType::BuiltinFunction(BuiltinFunction::NotDir)),
            ),

            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_o<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('r') => {
                let (start, chr) = it.next().unwrap();
                match_or(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_or<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('i') => {
                let (start, chr) = it.next().unwrap();
                match_ori(start + chr.len_utf8(), it)
            }
            Some(c) if !c.is_ascii_alphabetic() => (
                last_end,
                Some(TokenType::BuiltinFunction(BuiltinFunction::Or)),
            ),
            None => (
                last_end,
                Some(TokenType::BuiltinFunction(BuiltinFunction::Or)),
            ),

            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_ori<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('g') => {
                let (start, chr) = it.next().unwrap();
                match_orig(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_orig<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('i') => {
                let (start, chr) = it.next().unwrap();
                match_origi(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_origi<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('n') => {
                let (start, chr) = it.next().unwrap();
                match_origin(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_origin<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some(c) if !c.is_ascii_alphabetic() => (
                last_end,
                Some(TokenType::BuiltinFunction(BuiltinFunction::Origin)),
            ),
            None => (
                last_end,
                Some(TokenType::BuiltinFunction(BuiltinFunction::Origin)),
            ),

            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_p<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('a') => {
                let (start, chr) = it.next().unwrap();
                match_pa(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_pa<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('t') => {
                let (start, chr) = it.next().unwrap();
                match_pat(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_pat<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('s') => {
                let (start, chr) = it.next().unwrap();
                match_pats(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_pats<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('u') => {
                let (start, chr) = it.next().unwrap();
                match_patsu(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_patsu<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('b') => {
                let (start, chr) = it.next().unwrap();
                match_patsub(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_patsub<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('s') => {
                let (start, chr) = it.next().unwrap();
                match_patsubs(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_patsubs<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('t') => {
                let (start, chr) = it.next().unwrap();
                match_patsubst(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_patsubst<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some(c) if !c.is_ascii_alphabetic() => (
                last_end,
                Some(TokenType::BuiltinFunction(BuiltinFunction::PatSubst)),
            ),
            None => (
                last_end,
                Some(TokenType::BuiltinFunction(BuiltinFunction::PatSubst)),
            ),

            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_r<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('e') => {
                let (start, chr) = it.next().unwrap();
                match_re(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_re<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('a') => {
                let (start, chr) = it.next().unwrap();
                match_rea(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_rea<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('l') => {
                let (start, chr) = it.next().unwrap();
                match_real(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_real<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('p') => {
                let (start, chr) = it.next().unwrap();
                match_realp(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_realp<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('a') => {
                let (start, chr) = it.next().unwrap();
                match_realpa(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_realpa<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('t') => {
                let (start, chr) = it.next().unwrap();
                match_realpat(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_realpat<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('h') => {
                let (start, chr) = it.next().unwrap();
                match_realpath(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_realpath<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some(c) if !c.is_ascii_alphabetic() => (
                last_end,
                Some(TokenType::BuiltinFunction(BuiltinFunction::Realpath)),
            ),
            None => (
                last_end,
                Some(TokenType::BuiltinFunction(BuiltinFunction::Realpath)),
            ),

            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_w<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('a') => {
                let (start, chr) = it.next().unwrap();
                match_wa(start + chr.len_utf8(), it)
            }
            Some('i') => {
                let (start, chr) = it.next().unwrap();
                match_wi(start + chr.len_utf8(), it)
            }
            Some('o') => {
                let (start, chr) = it.next().unwrap();
                match_wo(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_wa<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('r') => {
                let (start, chr) = it.next().unwrap();
                match_war(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_war<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('n') => {
                let (start, chr) = it.next().unwrap();
                match_warn(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_warn<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('i') => {
                let (start, chr) = it.next().unwrap();
                match_warni(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_warni<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('n') => {
                let (start, chr) = it.next().unwrap();
                match_warnin(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_warnin<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('g') => {
                let (start, chr) = it.next().unwrap();
                match_warning(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_warning<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some(c) if !c.is_ascii_alphabetic() => (
                last_end,
                Some(TokenType::BuiltinFunction(BuiltinFunction::Warning)),
            ),
            None => (
                last_end,
                Some(TokenType::BuiltinFunction(BuiltinFunction::Warning)),
            ),

            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_wi<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('l') => {
                let (start, chr) = it.next().unwrap();
                match_wil(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_wil<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('d') => {
                let (start, chr) = it.next().unwrap();
                match_wild(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_wild<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('c') => {
                let (start, chr) = it.next().unwrap();
                match_wildc(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_wildc<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('a') => {
                let (start, chr) = it.next().unwrap();
                match_wildca(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_wildca<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('r') => {
                let (start, chr) = it.next().unwrap();
                match_wildcar(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_wildcar<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('d') => {
                let (start, chr) = it.next().unwrap();
                match_wildcard(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_wildcard<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some(c) if !c.is_ascii_alphabetic() => (
                last_end,
                Some(TokenType::BuiltinFunction(BuiltinFunction::Wildcard)),
            ),
            None => (
                last_end,
                Some(TokenType::BuiltinFunction(BuiltinFunction::Wildcard)),
            ),

            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_wo<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('r') => {
                let (start, chr) = it.next().unwrap();
                match_wor(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_wor<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('d') => {
                let (start, chr) = it.next().unwrap();
                match_word(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_word<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('l') => {
                let (start, chr) = it.next().unwrap();
                match_wordl(start + chr.len_utf8(), it)
            }
            Some('s') => {
                let (start, chr) = it.next().unwrap();
                match_words(start + chr.len_utf8(), it)
            }
            Some(c) if !c.is_ascii_alphabetic() => (
                last_end,
                Some(TokenType::BuiltinFunction(BuiltinFunction::Word)),
            ),
            None => (
                last_end,
                Some(TokenType::BuiltinFunction(BuiltinFunction::Word)),
            ),

            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_wordl<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('i') => {
                let (start, chr) = it.next().unwrap();
                match_wordli(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_wordli<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('s') => {
                let (start, chr) = it.next().unwrap();
                match_wordlis(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_wordlis<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some('t') => {
                let (start, chr) = it.next().unwrap();
                match_wordlist(start + chr.len_utf8(), it)
            }
            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_wordlist<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some(c) if !c.is_ascii_alphabetic() => (
                last_end,
                Some(TokenType::BuiltinFunction(BuiltinFunction::WordList)),
            ),
            None => (
                last_end,
                Some(TokenType::BuiltinFunction(BuiltinFunction::WordList)),
            ),

            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}

#[inline]
fn match_words<IT>(last_end: usize, it: &mut Peekable<IT>) -> (usize, Option<TokenType>)
where
    IT: Iterator<Item = (usize, char)>,
{
    if let Some((_, chr)) = it.peek() {
        match chr.to_lowercase().next() {
            Some(c) if !c.is_ascii_alphabetic() => (
                last_end,
                Some(TokenType::BuiltinFunction(BuiltinFunction::Words)),
            ),
            None => (
                last_end,
                Some(TokenType::BuiltinFunction(BuiltinFunction::Words)),
            ),

            _ => (last_end, None),
        }
    } else {
        (last_end, None)
    }
}
