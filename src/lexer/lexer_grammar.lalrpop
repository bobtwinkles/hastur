use crate::lexer::*;
use crate::tokenizer::*;

grammar;

extern {
    type Location = usize;
    type Error = crate::lexer::LexicalError;
    
    enum TokenType {
        "char" => TokenType::Text(_),
        "whitespace" => TokenType::Whitespace(_),
        "escaped_char" => TokenType::EscapedCharacter(_),
        "var_assign" => TokenType::VariableAssign(_),

        "text" => TokenType::Text,

        "export" => TokenType::Directive(Directive::Export),
        "include" => TokenType::Directive(Directive::Include),
        "load" => TokenType::Directive(Directive::Load),
        "unexport" => TokenType::Directive(Directive::UnExport),
        "vpath" => TokenType::Directive(Directive::VPath),
        "else" => TokenType::Directive(Directive::Else),
        "endif" => TokenType::Directive(Directive::Endif),
        "ifdef" => TokenType::Directive(Directive::IfDef),
        "ifeq" => TokenType::Directive(Directive::IfEq),
        "ifndef" => TokenType::Directive(Directive::IfNDef),
        "ifneq" => TokenType::Directive(Directive::IfNEq),
        "define" => TokenType::Directive(Directive::Define),
        "enddef" => TokenType::Directive(Directive::Enddef),

        "single_var" => TokenType::VariableReference(VariableKind::SingleCharacter),
        "$(" => TokenType::VariableReference(VariableKind::OpenParen),
        "${" =>  TokenType::VariableReference(VariableKind::OpenBrace),

        "abspath" => TokenType::BuiltinFunction(BuiltinFunction::Abspath),

        "(" => TokenType::OpenParen,
        ")" => TokenType::CloseParen,
        "{" => TokenType::OpenBrace,
        "}" => TokenType::CloseBrace,
        ":" => TokenType::Colon(IsDoubleColon::No),
        "::" => TokenType::Colon(IsDoubleColon::Yes),
        ";" => TokenType::SemiColon,
        "%" => TokenType::Percent,
        "\n" => TokenType::NewLine,
        "#" => TokenType::CommentStart,
        "\"" => TokenType::DoubleQuote,
        "'" => TokenType::SingleQuote,
        "," => TokenType::Comma,
    }
}

pub MakefileLine : MakefileLine = {
    <ConditionalLine> => MakefileLine::ConditionalLine(<>),
}

ConditionalLine : ConditionalLine = {
    <start:@L> "ifeq" "(" <a:VariableText> "," <b:VariableText> ")" <end:@R> "\n" => ConditionalLine {
        start: start,
        end: end,
    }
}

VariableText : VariableAstNode = {
    <AnyVariableWord*>
}

AnyVariableWord : VariableAstNode = {
    VariableReference,
    <start:@L> <special:VariableWordSpecials> <end:@R> => token_as_text(start, special, end)
}

#[inline]
VariableWordSpecials = {
   "text",
   // TODO: there are probably more things that need to go here
}

// Parsing variable references is tricky due to a combination of LALRPOP's
// insistence on LR(1) grammars and Make's highly cursed syntax. We need to
// support expressions like "${subst a,),aaa}" (which replaces the "a"s with
// ")"s), and thus need to effectively have 2 complete copies of the production
// rules
VariableReference : VariableAstNode = {
    <start:@L> "single_var" <end:@R> => VariableAstNode {
         dollar: start,
         start: start + 1,
         ty: VariableAstNodeTy::Text, 
         end: end,
    },
    <dollar:@L> "$(" <start:@L> <captured:VariableTextInParen> <end:@R> ")" => VariableAstNode {
         dollar,
         start, 
         ty: captured,
         end,
    },
    <dollar:@L> "${" <start:@L> <captured:VariableTextInBrace> <end:@R> "}" => VariableAstNode {
         dollar,
         start, 
         ty: captured,
         end,
    },
}

#[inline]
VariableTextInParen = VariableTextInternal<Braces>;
#[inline]
VariableTextInBrace = VariableTextInternal<Parens>;

#[inline]
VariableTextInternal<Accept> : VariableAstNodeTy = {
    <fst_start:@L> <fst:VariableTextNonFunction> <fst_end:@R> <rest:VariableTextRest<Accept>?> =>
        match rest {
            None => fst,
            Some(c) => VariableAstNodeTy::Concat(vec![VariableAstNode{ start: fst_start, ty: fst, end: fst_end }, c])
        },
    "abspath" "whitespace" <rest:VariableTextRest<Accept>> => VariableAstNodeTy::Abspath(rest),
}

#[inline]
VariableTextInit<Accept> = { <VariableTextNonFunction>, <Accept> }

#[inline]
VariableTextRest<Accept> : VariableAstNodeTy = {
    <vte:VariableTextElement<Accept>*> => VariableAstNodeTy::Concat(vte),
}

// #[inline]
VariableTextElement<Accept> : VariableAstNode = {
   <VariableReference>,
   <start:@L> <cap:VariableTextNonFunction> <end:@R> => token_as_text(<>),
   <start:@L> <cap:Accept> <end:@R> => token_as_text(start, cap, end),
}

#[inline]
VariableTextNonFunction = {
   "text",
   "escaped_char",
   "#",
   Directives,
   Colons
}

////////////////////////////////////////////////////////////////////////////////
// Various "utility" match classes
////////////////////////////////////////////////////////////////////////////////
#[inline]
Colons = { ":", "::" }
#[inline]
Braces = { "{", "}" }
#[inline]
Parens = { "(", ")" }

#[inline]
Directives = {
    "export",
    "include",
    "load",
    "unexport",
    "vpath",
    "else",
    "endif",
    "ifdef",
    "ifeq",
    "ifndef",
    "ifneq",
    "define",
    "enddef",
}