use crate::lexer::*;
use crate::tokenizer::*;

grammar;

extern {
    type Location = usize;
    type Error = crate::lexer::LexicalError;
    
    enum TokenType {
        "whitespace" => TokenType::Whitespace,
        "escaped_char" => TokenType::EscapedCharacter(_),
        "var_assign" => TokenType::VariableAssign(_),

        "text" => TokenType::Text,

        "export" => TokenType::Directive(Directive::Export),
        "include" => TokenType::Directive(Directive::Include(_)),
        "load" => TokenType::Directive(Directive::Load(_)),
        "unexport" => TokenType::Directive(Directive::UnExport),
        "vpath" => TokenType::Directive(Directive::VPath),
        "else" => TokenType::Directive(Directive::Else),
        "endif" => TokenType::Directive(Directive::EndIf),
        "ifdef" => TokenType::Directive(Directive::IfDef),
        "ifeq" => TokenType::Directive(Directive::IfEq),
        "ifndef" => TokenType::Directive(Directive::IfNDef),
        "ifneq" => TokenType::Directive(Directive::IfNEq),
        "define" => TokenType::Directive(Directive::Define),
        "enddef" => TokenType::Directive(Directive::Enddef),

        "single_var" => TokenType::VariableReference(VariableKind::SingleCharacter),
        "$(" => TokenType::VariableReference(VariableKind::OpenParen),
        "${" =>  TokenType::VariableReference(VariableKind::OpenBrace),

        "abspath" => TokenType::BuiltinFunction(BuiltinFunction::Abspath),

        "(" => TokenType::OpenParen,
        ")" => TokenType::CloseParen,
        "{" => TokenType::OpenBrace,
        "}" => TokenType::CloseBrace,
        ":" => TokenType::Colon(IsDoubleColon::No),
        "::" => TokenType::Colon(IsDoubleColon::Yes),
        ";" => TokenType::SemiColon,
        "%" => TokenType::Percent,
        "\n" => TokenType::NewLine,
        "#" => TokenType::CommentStart,
        "\"" => TokenType::DoubleQuote,
        "'" => TokenType::SingleQuote,
        "," => TokenType::Comma,
    }
}

pub MakefileLine : MakefileLine = <MakefileLineInner> Comment? EOL;

MakefileLineInner : MakefileLine = {
    <ConditionalLine> => MakefileLine::ConditionalLine(<>),
    "whitespace"* => MakefileLine::EmptyLine,
}

Comment = "#" AnyButNewline*;

ConditionalLine : ConditionalLine = {
    <start:@L> "ifeq" "whitespace"* <args:ConditionalEqArguments> <end:@R> => ConditionalLine {
        start: start,
        conditional: ConditionalTy::IfEq(args.0, args.1),
        end: end,
    },
    <start:@L> "ifneq" "whitespace"* <args:ConditionalEqArguments> <end:@R> => ConditionalLine {
        start: start,
        conditional: ConditionalTy::IfEq(args.0, args.1),
        end: end,
    }
}

ConditionalEqArguments : (VariableAstNode, VariableAstNode) = {
    "(" <a:VariableText> "," <b:VariableText> ")" => (a, b)
}

VariableText : VariableAstNode = <start:@L> <input:AnyVariableWord*> <end:@R> => {
        let mut words = input;
        match words.len() {
            0 => VariableAstNode {
                start, end,
                ty: VariableAstNodeTy::Text,
            },
            1 => words.remove(0),
            _ => VariableAstNode {
                start, end,
                ty: VariableAstNodeTy::Concat(words),
            },
        }
    };


AnyVariableWord : VariableAstNode = {
    <reference:VariableReference> => reference,
    <start:@L> <special:VariableWordSpecials> <end:@R> => token_as_text(start, special, end)
}

#[inline]
VariableWordSpecials = {
   "text",
   "whitespace",
   // TODO: there are probably more things that need to go here
}

// Parsing variable references is tricky due to a combination of LALRPOP's
// insistence on LR(1) grammars and Make's highly cursed syntax. We need to
// support expressions like "${subst a,),aaa}" (which replaces the "a"s with
// ")"s), and thus need to effectively have 2 complete copies of the production
// rules
#[inline]
VariableReference : VariableAstNode = {
   SingleVariableReference,
//   ParenVariableReference,
   BraceVariableReference,
}

SingleVariableReference : VariableAstNode =
    <start:@L> "single_var" <end:@R> => VariableAstNode {
        start: start,
        ty: VariableAstNodeTy::VariableReference {
            name: Box::new(VariableAstNode {
                 start: start + 1,
                 ty: VariableAstNodeTy::Text,
                 end: end,
            })
        }, 
        end: end,
    };

ParenVariableReference : VariableAstNode = 
    <dollar_start:@L> "$(" <start:@L> <captured:VariableTextInParen> <end:@R> ")" <dollar_end:@R> => VariableAstNode {
        start: dollar_start, 
        ty: VariableAstNodeTy::VariableReference {
            name: Box::new(VariableAstNode {
                start: start,
                ty: captured,
                end: end
            })
        },
        end: dollar_end,
    };


BraceVariableReference : VariableAstNode = 
    <dollar_start:@L> "${" <start:@L> <captured:VariableTextInBrace> <end:@R> "}" <dollar_end:@R> => VariableAstNode {
        start: dollar_start, 
        ty: VariableAstNodeTy::VariableReference {
            name: Box::new(VariableAstNode {
                start: start,
                ty: captured,
                end: end
            })
        },
        end: dollar_end,
    };


#[inline]
VariableTextInParen = VariableTextInternal<Braces>;

#[inline]
VariableTextInBrace = VariableTextInternal<Parens>;

#[inline]
VariableTextInternal<Accept> : VariableAstNodeTy = {
    NonFunction<Accept>,
    AbsPath<Accept>,
}

NonFunction<Accept> : VariableAstNodeTy =
    <fst_start:@L> <fst:VariableTextInit<Accept>> <fst_end:@R> <rest:VariableTextRest<Accept>?> =>
        match rest {
            None => fst,
            Some(c) => VariableAstNodeTy::Concat(vec![
                VariableAstNode{ start: fst_start, ty: fst, end: fst_end },
                c
            ])
        };

AbsPath<Accept> : VariableAstNodeTy =
    "abspath" "whitespace" <rest:VariableTextRest<Accept>> => VariableAstNodeTy::Abspath(Box::new(rest));

#[inline]
VariableTextInit<Accept> : VariableAstNodeTy = {
    <VariableTextNonFunction> => VariableAstNodeTy::Text,
    <Accept> => VariableAstNodeTy::Text,
}

#[inline]
VariableTextRest<Accept> : VariableAstNode = 
    <start:@L> <vte:VariableTextElement<Accept>+> <end:@R> =>
        VariableAstNode {
            start, end,
            ty: VariableAstNodeTy::Concat(vte)
        };


#[inline]
VariableTextElement<Accept> : VariableAstNode = {
    <VariableReference>,
    <start:@L> <cap:VariableTextNonFunction> <end:@R> => token_as_text(<>),
    <start:@L> <cap:Accept> <end:@R> => token_as_text(start, cap, end),
}

#[inline]
VariableTextNonFunction = {
   "text",
   "escaped_char",
   "#",
   Directives,
   Colons
}

////////////////////////////////////////////////////////////////////////////////
// Various "utility" match classes
////////////////////////////////////////////////////////////////////////////////
#[inline]
Colons = { ":", "::" }
#[inline]
Braces = { "{", "}" }
#[inline]
Parens = { "(", ")" }

#[inline]
Directives = {
    "export",
    "include",
    "load",
    "unexport",
    "vpath",
    "else",
    "endif",
    "ifdef",
    "ifeq",
    "ifndef",
    "ifneq",
    "define",
    "enddef",
}

AnyButNewline = {
    "whitespace",
    "escaped_char",
    "var_assign",
    
    "text",
    
    "export",
    "include",
    "load",
    "unexport",
    "vpath",
    "else",
    "endif",
    "ifdef",
    "ifeq",
    "ifndef",
    "ifneq",
    "define",
    "enddef",
    
    "single_var",
    "$(",
    "${",
    
    "abspath",
    
    "(",
    ")",
    "{",
    "}",
    ":",
    "::",
    ";",
    "%",
    "#",
    "\"",
    "'",
    ",",
}

EOL : Option<TokenType> = {
    <"\n"> => Some(<>),
    => None
}