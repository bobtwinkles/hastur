use crate::lexer::*;
use crate::tokenizer::*;

grammar;

extern {
    type Location = usize;
    type Error = crate::lexer::LexicalError;
    
    enum TokenType {
        "whitespace" => TokenType::Whitespace,
        "escaped_char" => TokenType::EscapedCharacter(_),
        "var_assign" => TokenType::VariableAssign(_),

        "text" => TokenType::Text,

        "export" => TokenType::Directive(Directive::Export),
        "include" => TokenType::Directive(Directive::Include(_)),
        "load" => TokenType::Directive(Directive::Load(_)),
        "unexport" => TokenType::Directive(Directive::UnExport),
        "vpath" => TokenType::Directive(Directive::VPath),
        "else" => TokenType::Directive(Directive::Else),
        "endif" => TokenType::Directive(Directive::EndIf),
        "ifdef" => TokenType::Directive(Directive::IfDef),
        "ifeq" => TokenType::Directive(Directive::IfEq),
        "ifndef" => TokenType::Directive(Directive::IfNDef),
        "ifneq" => TokenType::Directive(Directive::IfNEq),
        "define" => TokenType::Directive(Directive::Define),
        "enddef" => TokenType::Directive(Directive::Enddef),

        "single_var" => TokenType::VariableReference(VariableKind::SingleCharacter),
        "$(" => TokenType::VariableReference(VariableKind::OpenParen),
        "${" =>  TokenType::VariableReference(VariableKind::OpenBrace),

        "abspath" => TokenType::BuiltinFunction(BuiltinFunction::Abspath),
        "addprefix" => TokenType::BuiltinFunction(BuiltinFunction::AddPrefix),
        "addsuffix" => TokenType::BuiltinFunction(BuiltinFunction::AddSuffix),
        "and" => TokenType::BuiltinFunction(BuiltinFunction::And),
        "basename" => TokenType::BuiltinFunction(BuiltinFunction::BaseName),
        "call" => TokenType::BuiltinFunction(BuiltinFunction::Call),
        "dir" => TokenType::BuiltinFunction(BuiltinFunction::Dir),
        "error" => TokenType::BuiltinFunction(BuiltinFunction::Error),
        "eval" => TokenType::BuiltinFunction(BuiltinFunction::Eval),
        "file" => TokenType::BuiltinFunction(BuiltinFunction::File),
        "filter" => TokenType::BuiltinFunction(BuiltinFunction::Filter),
        "filterout" => TokenType::BuiltinFunction(BuiltinFunction::FilterOut),
        "findstring" => TokenType::BuiltinFunction(BuiltinFunction::FindString),
        "firstword" => TokenType::BuiltinFunction(BuiltinFunction::FirstWord),
        "flavor" => TokenType::BuiltinFunction(BuiltinFunction::Flavor),
        "if" => TokenType::BuiltinFunction(BuiltinFunction::If),
        "info" => TokenType::BuiltinFunction(BuiltinFunction::Info),
        "join" => TokenType::BuiltinFunction(BuiltinFunction::Join),
        "lastword" => TokenType::BuiltinFunction(BuiltinFunction::LastWord),
        "notdir" => TokenType::BuiltinFunction(BuiltinFunction::NotDir),
        "or" => TokenType::BuiltinFunction(BuiltinFunction::Or),
        "origin" => TokenType::BuiltinFunction(BuiltinFunction::Origin),
        "patsubst" => TokenType::BuiltinFunction(BuiltinFunction::PatSubst),
        "realpath" => TokenType::BuiltinFunction(BuiltinFunction::Realpath),
        "sort" => TokenType::BuiltinFunction(BuiltinFunction::Sort),
        "strip" => TokenType::BuiltinFunction(BuiltinFunction::Strip),
        "subst" => TokenType::BuiltinFunction(BuiltinFunction::Subst),
        "suffix" => TokenType::BuiltinFunction(BuiltinFunction::Suffix),
        "value" => TokenType::BuiltinFunction(BuiltinFunction::Value),
        "warning" => TokenType::BuiltinFunction(BuiltinFunction::Warning),
        "wildcard" => TokenType::BuiltinFunction(BuiltinFunction::Wildcard),
        "word" => TokenType::BuiltinFunction(BuiltinFunction::Word),
        "wordlist" => TokenType::BuiltinFunction(BuiltinFunction::WordList),
        "words" => TokenType::BuiltinFunction(BuiltinFunction::Words),

        "(" => TokenType::OpenParen,
        ")" => TokenType::CloseParen,
        "{" => TokenType::OpenBrace,
        "}" => TokenType::CloseBrace,
        ":" => TokenType::Colon(IsDoubleColon::No),
        "::" => TokenType::Colon(IsDoubleColon::Yes),
        ";" => TokenType::SemiColon,
        "%" => TokenType::Percent,
        "\n" => TokenType::NewLine,
        "#" => TokenType::CommentStart,
        "\"" => TokenType::DoubleQuote,
        "'" => TokenType::SingleQuote,
        "," => TokenType::Comma,
    }
}

pub MakefileLine : MakefileLine = <MakefileLineInner> Comment? EOL;

MakefileLineInner : MakefileLine = {
    <ConditionalLine> Whitespace => MakefileLine::ConditionalLine(<>),
    Whitespace => MakefileLine::EmptyLine,
}

Comment = "#" AnyButNewline*;

ConditionalLine : ConditionalLine = {
    <start:@L> "ifeq" "whitespace"* <args:ConditionalEqArguments> <end:@R> => ConditionalLine {
        start: start,
        conditional: ConditionalTy::IfEq(args.0, args.1),
        end: end,
    },
    <start:@L> "ifneq" "whitespace"* <args:ConditionalEqArguments> <end:@R> => ConditionalLine {
        start: start,
        conditional: ConditionalTy::IfEq(args.0, args.1),
        end: end,
    }
}

ConditionalEqArguments : (VariableAstNode, VariableAstNode) = {
    "(" <a:VariableText> "," <b:VariableText> ")" => (a, b)
}

VariableText : VariableAstNode = <start:@L> <input:AnyVariableWord*> <end:@R> => {
        let mut words = input;
        match words.len() {
            0 => VariableAstNode {
                start, end,
                ty: VariableAstNodeTy::Text,
            },
            1 => words.remove(0),
            _ => VariableAstNode {
                start, end,
                ty: VariableAstNodeTy::Concat(words),
            },
        }
    };


AnyVariableWord : VariableAstNode = {
    <reference:VariableReference> => reference,
    <start:@L> <special:VariableWordSpecials> <end:@R> => token_as_text(start, special, end)
}

#[inline]
VariableWordSpecials = {
   "text",
   "whitespace",
   // TODO: there are probably more things that need to go here
}

// Parsing variable references is tricky due to a combination of LALRPOP's
// insistence on LR(1) grammars and Make's highly cursed syntax. We need to
// support expressions like "${subst a,),aaa}" (which replaces the "a"s with
// ")"s), and thus need to effectively have 2 complete copies of the production
// rules
#[inline]
VariableReference : VariableAstNode = {
   SingleVariableReference,
//   ParenVariableReference,
   BraceVariableReference,
}

SingleVariableReference : VariableAstNode =
    <start:@L> "single_var" <end:@R> => VariableAstNode {
        start: start,
        ty: VariableAstNodeTy::VariableReference {
            name: Box::new(VariableAstNode {
                 start: start + 1,
                 ty: VariableAstNodeTy::Text,
                 end: end,
            })
        }, 
        end: end,
    };

ParenVariableReference : VariableAstNode = 
    <dollar_start:@L> "$(" <start:@L> <captured:VariableTextInParen> <end:@R> ")" <dollar_end:@R> => VariableAstNode {
        start: dollar_start, 
        ty: VariableAstNodeTy::VariableReference {
            name: Box::new(VariableAstNode {
                start: start,
                ty: captured,
                end: end
            })
        },
        end: dollar_end,
    };


BraceVariableReference : VariableAstNode = 
    <dollar_start:@L> "${" <start:@L> <captured:VariableTextInBrace> <end:@R> "}" <dollar_end:@R> => VariableAstNode {
        start: dollar_start, 
        ty: VariableAstNodeTy::VariableReference {
            name: Box::new(VariableAstNode {
                start: start,
                ty: captured,
                end: end
            })
        },
        end: dollar_end,
    };


#[inline]
VariableTextInParen = VariableTextInternal<Braces>;

#[inline]
VariableTextInBrace = VariableTextInternal<Parens>;

VariableTextInternal<Accept> : VariableAstNodeTy = {
    <fst_start:@L> <fst:VariableTextInit<Accept>> <fst_end:@R> <rest:VariableTextRest<Accept>?> =>
        match rest {
            None => fst,
            Some(c) => VariableAstNodeTy::Concat(vec![
                VariableAstNode{ start: fst_start, ty: fst, end: fst_end },
                c
            ])
        },
    "abspath" "whitespace" <rest:VariableTextRest<Accept>> => VariableAstNodeTy::Abspath(Box::new(rest)),
}

#[inline]
VariableTextInit<Accept> : VariableAstNodeTy = {
    <VariableTextNonFunction> => VariableAstNodeTy::Text,
    <Accept> => VariableAstNodeTy::Text,
}

#[inline]
VariableTextRest<Accept> : VariableAstNode = 
    <start:@L> <vte:VariableTextElement<Accept>+> <end:@R> =>
        VariableAstNode {
            start, end,
            ty: VariableAstNodeTy::Concat(vte)
        };


#[inline]
VariableTextElement<Accept> : VariableAstNode = {
    <VariableReference>,
    <start:@L> <cap:VariableTextNonFunction> <end:@R> => token_as_text(<>),
    <start:@L> <cap:Accept> <end:@R> => token_as_text(start, cap, end),
}

#[inline]
VariableTextNonFunction = {
   "text",
   "escaped_char",
   "#",
   Directive,
   Colons
}

////////////////////////////////////////////////////////////////////////////////
// Various "utility" match classes
////////////////////////////////////////////////////////////////////////////////
#[inline]
Colons = { ":", "::" }
#[inline]
Braces = { "{", "}" }
#[inline]
Parens = { "(", ")" }

#[inline]
Directive = {
    "export",
    "include",
    "load",
    "unexport",
    "vpath",
    "else",
    "endif",
    "ifdef",
    "ifeq",
    "ifndef",
    "ifneq",
    "define",
    "enddef",
}

#[inline]
FunctionName = {
    "abspath",
    "addprefix",
    "addsuffix",
    "and",
    "basename",
    "call",
    "dir",
    "error",
    "eval",
    "file",
    "filter",
    "filterout",
    "findstring",
    "firstword",
    "flavor",
    "if",
    "info",
    "join",
    "lastword",
    "notdir",
    "or",
    "origin",
    "patsubst",
    "realpath",
    "sort",
    "strip",
    "subst",
    "suffix",
    "value",
    "warning",
    "wildcard",
    "word",
    "wordlist",
    "words",
}

AnyButNewline = {
    "whitespace",
    "escaped_char",
    "var_assign",
    
    "text",

    FunctionName,
    Directive,
    
    "single_var",
    "$(",
    "${",
    
    "(",
    ")",
    "{",
    "}",
    ":",
    "::",
    ";",
    "%",
    "#",
    "\"",
    "'",
    ",",
}

Whitespace = "whitespace"*;

EOL : Option<TokenType> = {
    <"\n"> => Some(<>),
    => None
}