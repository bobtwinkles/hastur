use crate::lexer::*;
use crate::tokenizer::*;

grammar;

extern {
    type Location = usize;
    type Error = crate::lexer::LexicalError;

    enum TokenType {
        "whitespace" => TokenType::Whitespace,
        "escaped_char" => TokenType::EscapedCharacter(_),
        "var_assign" => TokenType::VariableAssign(_),

        "text" => TokenType::Text,

        "define" => TokenType::Directive(Directive::Define),
        "else" => TokenType::Directive(Directive::Else),
        "enddef" => TokenType::Directive(Directive::Enddef),
        "endif" => TokenType::Directive(Directive::EndIf),
        "export" => TokenType::Directive(Directive::Export),
        "ifdef" => TokenType::Directive(Directive::IfDef),
        "ifeq" => TokenType::Directive(Directive::IfEq),
        "ifndef" => TokenType::Directive(Directive::IfNDef),
        "ifneq" => TokenType::Directive(Directive::IfNEq),
        "include" => TokenType::Directive(Directive::Include(_)),
        "load" => TokenType::Directive(Directive::Load(_)),
        "override" => TokenType::Directive(Directive::Override),
        "private" => TokenType::Directive(Directive::Private),
        "undefine" => TokenType::Directive(Directive::Undefine),
        "unexport" => TokenType::Directive(Directive::UnExport),
        "vpath" => TokenType::Directive(Directive::VPath),

        "single_var" => TokenType::VariableReference(VariableKind::SingleCharacter),
        "$(" => TokenType::VariableReference(VariableKind::OpenParen),
        "${" =>  TokenType::VariableReference(VariableKind::OpenBrace),

        "abspath" => TokenType::BuiltinFunction(BuiltinFunction::Abspath),
        "addprefix" => TokenType::BuiltinFunction(BuiltinFunction::AddPrefix),
        "addsuffix" => TokenType::BuiltinFunction(BuiltinFunction::AddSuffix),
        "and" => TokenType::BuiltinFunction(BuiltinFunction::And),
        "basename" => TokenType::BuiltinFunction(BuiltinFunction::BaseName),
        "call" => TokenType::BuiltinFunction(BuiltinFunction::Call),
        "dir" => TokenType::BuiltinFunction(BuiltinFunction::Dir),
        "error" => TokenType::BuiltinFunction(BuiltinFunction::Error),
        "eval" => TokenType::BuiltinFunction(BuiltinFunction::Eval),
        "file" => TokenType::BuiltinFunction(BuiltinFunction::File),
        "filter" => TokenType::BuiltinFunction(BuiltinFunction::Filter),
        "filterout" => TokenType::BuiltinFunction(BuiltinFunction::FilterOut),
        "findstring" => TokenType::BuiltinFunction(BuiltinFunction::FindString),
        "firstword" => TokenType::BuiltinFunction(BuiltinFunction::FirstWord),
        "flavor" => TokenType::BuiltinFunction(BuiltinFunction::Flavor),
        "if" => TokenType::BuiltinFunction(BuiltinFunction::If),
        "info" => TokenType::BuiltinFunction(BuiltinFunction::Info),
        "join" => TokenType::BuiltinFunction(BuiltinFunction::Join),
        "lastword" => TokenType::BuiltinFunction(BuiltinFunction::LastWord),
        "notdir" => TokenType::BuiltinFunction(BuiltinFunction::NotDir),
        "or" => TokenType::BuiltinFunction(BuiltinFunction::Or),
        "origin" => TokenType::BuiltinFunction(BuiltinFunction::Origin),
        "patsubst" => TokenType::BuiltinFunction(BuiltinFunction::PatSubst),
        "realpath" => TokenType::BuiltinFunction(BuiltinFunction::Realpath),
        "sort" => TokenType::BuiltinFunction(BuiltinFunction::Sort),
        "strip" => TokenType::BuiltinFunction(BuiltinFunction::Strip),
        "subst" => TokenType::BuiltinFunction(BuiltinFunction::Subst),
        "suffix" => TokenType::BuiltinFunction(BuiltinFunction::Suffix),
        "value" => TokenType::BuiltinFunction(BuiltinFunction::Value),
        "warning" => TokenType::BuiltinFunction(BuiltinFunction::Warning),
        "wildcard" => TokenType::BuiltinFunction(BuiltinFunction::Wildcard),
        "word" => TokenType::BuiltinFunction(BuiltinFunction::Word),
        "wordlist" => TokenType::BuiltinFunction(BuiltinFunction::WordList),
        "words" => TokenType::BuiltinFunction(BuiltinFunction::Words),

        "=" => TokenType::VariableAssign(VariableAssign::Recursive),
        ":=" => TokenType::VariableAssign(VariableAssign::Simple(IsDoubleColon::No)),
        "::=" => TokenType::VariableAssign(VariableAssign::Simple(IsDoubleColon::Yes)),
        "+=" => TokenType::VariableAssign(VariableAssign::Append),
        "?=" => TokenType::VariableAssign(VariableAssign::Conditional),
        "!=" => TokenType::VariableAssign(VariableAssign::Bang),

        "(" => TokenType::OpenParen,
        ")" => TokenType::CloseParen,
        "{" => TokenType::OpenBrace,
        "}" => TokenType::CloseBrace,
        ":" => TokenType::Colon(IsDoubleColon::No),
        "::" => TokenType::Colon(IsDoubleColon::Yes),
        ";" => TokenType::SemiColon,
        "%" => TokenType::Percent,
        "\n" => TokenType::NewLine,
        "#" => TokenType::CommentStart,
        "\"" => TokenType::DoubleQuote,
        "'" => TokenType::SingleQuote,
        "," => TokenType::Comma,
    }
}

pub MakefileLine : MakefileLine = {
    Whitespace <MakefileLineInner> Comment? EOL => <>,
    Whitespace Comment? EOL => MakefileLine::EmptyLine,
}

MakefileLineInner : MakefileLine = {
    <ConditionalLine> => MakefileLine::ConditionalLine(<>),
    <VariableLine> => MakefileLine::VariableLine(<>),
    <TargetLine> => MakefileLine::TargetLine(<>),
}

Comment = "#" AnyButNewline*;

/// A line that starts with a conditional directive
ConditionalLine : ConditionalLine = {
    <start:@L> <conditional:AnyConditional> => ConditionalLine {
        start,
        end: conditional.1,
        conditional: conditional.0,
    }
}

AnyConditional : (ConditionalTy, usize) = {
    <IfEq>,
    <IfDef>,
    <Else>,
    "endif" <end:@R> Whitespace => (ConditionalTy::EndIf, end),
}

#[inline]
IfEq : (ConditionalTy, usize) = {
    "ifeq" Whitespace <args:ConditionalEqArguments> <end:@R> Whitespace =>
        (ConditionalTy::IfEq(args.0, args.1), end),
    "ifneq" Whitespace <args:ConditionalEqArguments> <end:@R> Whitespace =>
        (ConditionalTy::IfNEq(args.0, args.1), end),
}

ConditionalEqArguments : (VariableAstNode, VariableAstNode) = {
    "(" Whitespace <a:VariableText> "," Whitespace <b:VariableText> ")" => (a, b),
    <a:ConditionalEqArg> WhitespaceReq <b:ConditionalEqArg> => (a, b)
}

ConditionalEqArg : VariableAstNode = {
    "\"" <VariableText> "\"",
    "'" <VariableText> "'",
}

#[inline]
IfDef : (ConditionalTy, usize) = {
    "ifdef" Whitespace <t:VariableText> <end:@R> => (ConditionalTy::IfDef(t), end),
    "ifndef" Whitespace <t:VariableText> <end:@R> => (ConditionalTy::IfNDef(t), end),
}

#[inline]
Else : (ConditionalTy, usize) = {
     "else" <end:@R> Whitespace => (ConditionalTy::Else(None), end),
     "else" WhitespaceReq <next:IfEq> => (ConditionalTy::Else(Some(Box::new(next.0))), next.1),
     "else" WhitespaceReq <next:IfDef> => (ConditionalTy::Else(Some(Box::new(next.0))), next.1),
}

/// A line that represents an assignment operation
VariableLine : VariableLine = {
    <start:@L> <modifiers:ModifierStack> <name:VariableText> <op:AssignmentOperator> Whitespace
                                                  <value:VariableText> <end:@R> => {
        if let TokenType::VariableAssign(ty) = op {
            VariableLine {
                start, end, name, value, ty, modifiers,
            }
        } else {
            panic!("grammar bug: AssignmentOperator matches things that are not, in fact, assignment operators");
        }
    }
}

#[inline]
ModifierStack: Modifiers = <parse_modifiers:(Modifier WhitespaceReq)*> => {
        let mut modifiers = Modifiers::default();
        for (modifier, _) in parse_modifiers {
            match modifier {
                Modifier::Export => modifiers.export = true,
                Modifier::Override => modifiers.mod_override = true,
                Modifier::Private => modifiers.private = true,
            }
        }
        modifiers
    };

Modifier : Modifier = {
    "export" => Modifier::Export,
    "override" => Modifier::Override,
    "private" => Modifier::Private,
}

/// A target lines is anything that begins with a list of targets followed by a : or ::
TargetLine: TargetLine = {
    <start:@L> <targets:VariableText> <sep:TargetSeparator> Whitespace <deps:VariableText> <end:@R> =>
        TargetLine {
            start, end, targets,
            ty: TargetLineTy::DepLine {
                is_double_colon: sep,
                deps
            }
        },
    <start:@L> <targets:VariableText> TargetSeparator Whitespace <varline: VariableLine> <end:@R> =>
        TargetLine {
            start, end, targets,
            ty: TargetLineTy::VariableOp(Box::new(varline))
        }
}

TargetSeparator : IsDoubleColon = {
    ":" => IsDoubleColon::No,
    "::" => IsDoubleColon::Yes
}

/// The primary entry point for parsing text that may include variable expansions
VariableText : VariableAstNode = <start:@L> <input:(AnyVariableWord Whitespace)+> <end:@R> => {
        use std::iter;
        let mut words = input;
        match words.len() {
            0 => unreachable!("at least one variable word should have been mached -- this is a bug in the grammar"),
            1 => words.remove(0).0,
            _ => VariableAstNode {
                start, end,
                ty: VariableAstNodeTy::Concat(words.into_iter().flat_map(|x| {
                    iter::once(x.0).chain(iter::once(x.1))
                }).collect()),
            },
        }
    };


AnyVariableWord : VariableAstNode = {
    <reference:VariableReference> => reference,
    <start:@L> <special:VariableWordSpecials> <end:@R> => token_as_text(start, special, end)
}

#[inline]
VariableWordSpecials = {
   "text",
   // TODO: there are probably more things that need to go here
}

// Parsing variable references is tricky due to a combination of LALRPOP's
// insistence on LR(1) grammars and Make's highly cursed syntax. We need to
// support expressions like "${subst a,),aaa}" (which replaces the "a"s with
// ")"s), and thus need to effectively have 2 complete copies of the production
// rules
#[inline]
VariableReference : VariableAstNode = {
   SingleVariableReference,
//   ParenVariableReference,
   BraceVariableReference,
}

SingleVariableReference : VariableAstNode =
    <start:@L> "single_var" <end:@R> => VariableAstNode {
        start: start,
        ty: VariableAstNodeTy::VariableReference {
            name: Box::new(VariableAstNode {
                 start: start + 1,
                 ty: VariableAstNodeTy::Text,
                 end: end,
            })
        },
        end: end,
    };

ParenVariableReference : VariableAstNode =
    <dollar_start:@L> "$(" <start:@L> <captured:VariableTextInParen> <end:@R> ")" <dollar_end:@R> => VariableAstNode {
        start: dollar_start,
        ty: VariableAstNodeTy::VariableReference {
            name: Box::new(VariableAstNode {
                start: start,
                ty: captured,
                end: end
            })
        },
        end: dollar_end,
    };


BraceVariableReference : VariableAstNode =
    <dollar_start:@L> "${" <start:@L> <captured:VariableTextInBrace> <end:@R> "}" <dollar_end:@R> => VariableAstNode {
        start: dollar_start,
        ty: VariableAstNodeTy::VariableReference {
            name: Box::new(VariableAstNode {
                start: start,
                ty: captured,
                end: end
            })
        },
        end: dollar_end,
    };


#[inline]
VariableTextInParen = VariableTextInternal<Braces>;

#[inline]
VariableTextInBrace = VariableTextInternal<Parens>;

VariableTextInternal<Accept> : VariableAstNodeTy = {
    <fst_start:@L> <fst:VariableTextInit<Accept>> <fst_end:@R> <rest:VariableTextRest<Accept>?> =>
        match rest {
            None => fst,
            Some(c) => VariableAstNodeTy::Concat(vec![
                VariableAstNode{ start: fst_start, ty: fst, end: fst_end },
                c
            ])
        },
    "abspath" "whitespace" <rest:VariableTextRest<Accept>> => VariableAstNodeTy::Abspath(Box::new(rest)),
}

#[inline]
VariableTextInit<Accept> : VariableAstNodeTy = {
    <VariableTextNonFunction> => VariableAstNodeTy::Text,
    <Accept> => VariableAstNodeTy::Text,
}

#[inline]
VariableTextRest<Accept> : VariableAstNode =
    <start:@L> <vte:VariableTextElement<Accept>+> <end:@R> =>
        VariableAstNode {
            start, end,
            ty: VariableAstNodeTy::Concat(vte)
        };


#[inline]
VariableTextElement<Accept> : VariableAstNode = {
    <VariableReference>,
    <start:@L> <cap:VariableTextNonFunction> <end:@R> => token_as_text(<>),
    <start:@L> <cap:Accept> <end:@R> => token_as_text(start, cap, end),
}

#[inline]
VariableTextNonFunction = {
   "text",
   "escaped_char",
   "#",
   Directive,
   Colons,
   AssignmentOperator,
}

////////////////////////////////////////////////////////////////////////////////
// Various "utility" match classes
////////////////////////////////////////////////////////////////////////////////
#[inline]
Colons = { ":", "::" }
#[inline]
Braces = { "{", "}" }
#[inline]
Parens = { "(", ")" }

#[inline]
Directive = {
    "define",
    "else",
    "enddef",
    "endif",
    "export",
    "ifdef",
    "ifeq",
    "ifndef",
    "ifneq",
    "include",
    "load",
    "override",
    "private",
    "unexport",
    "vpath",
}

#[inline]
FunctionName = {
    "abspath",
    "addprefix",
    "addsuffix",
    "and",
    "basename",
    "call",
    "dir",
    "error",
    "eval",
    "file",
    "filter",
    "filterout",
    "findstring",
    "firstword",
    "flavor",
    "if",
    "info",
    "join",
    "lastword",
    "notdir",
    "or",
    "origin",
    "patsubst",
    "realpath",
    "sort",
    "strip",
    "subst",
    "suffix",
    "value",
    "warning",
    "wildcard",
    "word",
    "wordlist",
    "words",
}

AnyButNewline = {
    "whitespace",
    "escaped_char",
    "var_assign",

    "text",

    FunctionName,
    Directive,

    "single_var",
    "$(",
    "${",

    "(",
    ")",
    "{",
    "}",
    ":",
    "::",
    ";",
    "%",
    "#",
    "\"",
    "'",
    ",",
}

#[inline]
Whitespace: VariableAstNode = <start:@L> "whitespace"* <end:@R>
    => token_as_text(start, TokenType::Whitespace, end);

#[inline]
WhitespaceReq: VariableAstNode = <start:@L> "whitespace"+ <end:@R>
    => token_as_text(start, TokenType::Whitespace, end);

EOL : Option<TokenType> = {
    <"\n"> => Some(<>),
    => None
}

#[inline]
AssignmentOperator = {
    "=",
    ":=",
    "::=",
    "+=",
    "?=",
    "!=",
}
